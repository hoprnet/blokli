{"id":"blokli-0rh","content_hash":"69cfc1fdde8e6f00e6bbc726892ee347400dfad6863040c9b4c0c76d7dfb5c7c","title":"use runtime-tokio by default always","description":"Configure the runtime-tokio feature to be used by default so it does not have to be specified explicitely for cargo on the CLI always.","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-07T15:45:04.265162485+01:00","updated_at":"2025-11-07T15:45:04.265162485+01:00","source_repo":"."}
{"id":"blokli-0rm","content_hash":"d289277309f6ea7dd75bc14405ec370c99d97f8a106e09699ee5776ed21032af","title":"Update handler test documentation","description":"Document event capture pattern in handlers.rs test module. Add examples of using init_handlers_with_events(), document when to use try_recv_event() vs recv().await, add notes about is_synced parameter for event publication. See TODO.md for example documentation template. Estimated: 30 minutes.","status":"open","priority":4,"issue_type":"task","created_at":"2025-11-06T12:38:05.787103362+01:00","updated_at":"2025-11-06T12:38:05.787103362+01:00","source_repo":"."}
{"id":"blokli-0w4","content_hash":"a36330f861362c36b25ee2cb5659572a16bda7808dd940d55accf2aaac2ea792","title":"Update RpcOperationsConfig and RpcOperations","description":"Remove expected_block_time from config, add block_time_window_size and initial_block_time, initialize BlockTimeTracker in RpcOperations::new()","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.398793798+01:00","updated_at":"2025-12-01T20:04:23.398793798+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-0w4","depends_on_id":"blokli-3ca","type":"blocks","created_at":"2025-12-01T20:04:26.029040628+01:00","created_by":"daemon"}]}
{"id":"blokli-1w5","content_hash":"9732e5f00bc5d8ae7e115e5a5188101200146991a1269d8cad272dbcb8ec8a24","title":"Phase 4: Test Scenarios and Validation","description":"Create baseline test scenarios (5), add justfile commands, validate and debug (12 hours / 1 day)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:35.430401445+01:00","updated_at":"2025-12-02T09:26:35.430401445+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-1w5","depends_on_id":"blokli-qk6","type":"blocks","created_at":"2025-12-02T09:26:44.150737292+01:00","created_by":"daemon"},{"issue_id":"blokli-1w5","depends_on_id":"blokli-bnn","type":"blocks","created_at":"2025-12-02T09:26:44.158652964+01:00","created_by":"daemon"},{"issue_id":"blokli-1w5","depends_on_id":"blokli-jk0","type":"blocks","created_at":"2025-12-02T09:26:44.16630371+01:00","created_by":"daemon"}]}
{"id":"blokli-2l2","content_hash":"9ac656d3c72dbdb749fda7029eb6a81f3249c9ffadc7ca65395f92f2d7217f7c","title":"Phase 2.6: Testing and Docker Integration","description":"Unit tests for parsing/validation, integration tests with mocks, Dockerfile, end-to-end Docker Compose test","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.726228704+01:00","updated_at":"2025-12-02T09:26:16.726228704+01:00","source_repo":"."}
{"id":"blokli-2s8","content_hash":"f09441070e75010b572fad87a444f069d15c60242b5a0a07e97ff327e3c93521","title":"Phase 1: Bot Runner Service","description":"Implement bot pool manager, REST API endpoints, event storage, and blokli-client integration (26-28 hours / 2-3 days)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:25:48.246922698+01:00","updated_at":"2025-12-02T09:25:48.246922698+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-2s8","depends_on_id":"blokli-crp","type":"blocks","created_at":"2025-12-02T09:26:07.358599744+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-mam","type":"blocks","created_at":"2025-12-02T09:26:07.366262051+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-hcs","type":"blocks","created_at":"2025-12-02T09:26:07.373712621+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-ccu","type":"blocks","created_at":"2025-12-02T09:26:07.3814449+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-82w","type":"blocks","created_at":"2025-12-02T09:26:07.389703645+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-7vy","type":"blocks","created_at":"2025-12-02T09:26:07.39715719+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-6xk","type":"blocks","created_at":"2025-12-02T09:26:07.404912722+01:00","created_by":"daemon"},{"issue_id":"blokli-2s8","depends_on_id":"blokli-u2z","type":"blocks","created_at":"2025-12-02T09:26:46.844458346+01:00","created_by":"daemon"}]}
{"id":"blokli-3ca","content_hash":"aa60152403ad2c552479a083c364263c2b49a47e8d68c500d4b9be795cd0a294","title":"Create BlockTimeTracker module (chain/rpc/src/block_time_tracker.rs)","description":"Implement BlockTimeTracker struct with moving average calculation, VecDeque-based circular buffer, Arc\u003cRwLock\u003e wrapper for thread-safe access, and unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.391972761+01:00","updated_at":"2025-12-01T20:04:23.391972761+01:00","source_repo":"."}
{"id":"blokli-3s7","content_hash":"f57edf50003e3be08111378270a1fecbc4421d34e0e69f4fb612d037fd96f16d","title":"Update indexer polling logic","description":"Modify indexer.rs try_stream_logs() to use dynamic block_time_tracker instead of static expected_block_time","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.407225127+01:00","updated_at":"2025-12-01T20:04:23.407225127+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-3s7","depends_on_id":"blokli-0w4","type":"blocks","created_at":"2025-12-01T20:04:26.037645703+01:00","created_by":"daemon"}]}
{"id":"blokli-3u1","content_hash":"40cbdfd01e23206dca6cfff86d249880c3eca1486bbb561bd6ae65516f5e942b","title":"Add gas price query and subscription to GraphQL API","description":"\nDESIGN: Gas Price Support\n\nSCHEMA CHANGES:\n- New Query: gasPrice: GasPriceResult!\n- New Subscription: gasPriceUpdated: GasPrice!\n- Types: GasPrice (baseFee, priorityFee, updatedAt), GasPriceResult union\n\nIMPLEMENTATION:\n- Store gas price in-memory only (no database persistence)\n- Indexer: Extract baseFeePerGas from block headers, cache in-memory\n- Indexer: Periodically fetch priorityFee from RPC\n- Indexer: Broadcast GasPriceUpdated events when values change\n- API Query: Read from in-memory cache, return QueryFailedError if not initialized\n- API Subscription: Emit current value as snapshot, stream subsequent updates\n- On restart: Gas price resets, clients get fresh data\n\nNO DATABASE CHANGES - data is too volatile to persist\n","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-01T20:09:45.381566467+01:00","updated_at":"2025-12-01T20:09:45.381566467+01:00","source_repo":"."}
{"id":"blokli-49e","content_hash":"cd1be63e6fdb9ad6b89c10812aafe2a39629c2b1478312746e1d83aa68d3cc96","title":"Phase 2.3: Scenario Executor and Action Handlers","description":"Implement ScenarioExecutor, action executors for subscribe/trigger/verify, cross-step state management","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.705191449+01:00","updated_at":"2025-12-02T09:26:16.705191449+01:00","source_repo":"."}
{"id":"blokli-4rw","content_hash":"ffce7d1e7b08b9cda3b691a24bac35e36f11c174304c3c1860658c82b0dcd394","title":"Phase 2.5: Report Generation","description":"Implement JSON and Markdown report builders, write reports to /reports volume, include event timelines","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.719694803+01:00","updated_at":"2025-12-02T09:26:16.719694803+01:00","source_repo":"."}
{"id":"blokli-5bj","content_hash":"c0110213dd46393ad80a5a8d1b2f05042a1ee5e764ad34a95cf899788e86db73","title":"Phase 3: Docker Compose Infrastructure","description":"Set up contract deployment, configuration files, Docker Compose orchestration, and integration testing (15-16 hours / 1-2 days)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:22.382591276+01:00","updated_at":"2025-12-02T09:26:22.382591276+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-5bj","depends_on_id":"blokli-p5k","type":"blocks","created_at":"2025-12-02T09:26:31.883321599+01:00","created_by":"daemon"},{"issue_id":"blokli-5bj","depends_on_id":"blokli-6s8","type":"blocks","created_at":"2025-12-02T09:26:31.891288959+01:00","created_by":"daemon"},{"issue_id":"blokli-5bj","depends_on_id":"blokli-o5t","type":"blocks","created_at":"2025-12-02T09:26:31.899364601+01:00","created_by":"daemon"},{"issue_id":"blokli-5bj","depends_on_id":"blokli-cbp","type":"blocks","created_at":"2025-12-02T09:26:31.907258573+01:00","created_by":"daemon"},{"issue_id":"blokli-5bj","depends_on_id":"blokli-1w5","type":"blocks","created_at":"2025-12-02T09:26:46.860091059+01:00","created_by":"daemon"}]}
{"id":"blokli-6s8","content_hash":"d5d78e9f5848e4a015a52c4eb665978e45a1470570b01df3f81fbd7c182369b3","title":"Phase 3.2: Configuration Files","description":"Create blokli-e2e.toml with Anvil RPC, PostgreSQL connection, contract addresses, API settings","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:29.045962305+01:00","updated_at":"2025-12-02T09:26:29.045962305+01:00","source_repo":"."}
{"id":"blokli-6xk","content_hash":"caf280497e94e2c635ba2b4c841b3bbd248c16f9d345aa89c965e28211aef5af","title":"Phase 1.7: Testing and Docker Integration","description":"Unit tests, integration tests with mocks, Dockerfile build, container startup validation with BOT_COUNT scaling","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.152458436+01:00","updated_at":"2025-12-02T09:26:04.152458436+01:00","source_repo":"."}
{"id":"blokli-77w","content_hash":"d3e47aa715027fa866d9eec9831975045f996ec48ccab81648b70841aad1eddf","title":"native and hopr balance support","description":"The GraphQL API allows querying of hopr and native balances. This only makes sense to support for HOPR safes, HOPR node EOA accounts and the channels contract.\nEven then the amount of chain logs which would have to be stored is a lot. Thus blokli uses the following approach. \nDuring initial sync transfer logs (ERC20) and transfer transactions (native) are completely ignored. Once synched the indexer also subscribes to these events. \nInternally blokli keeps an in-memory set of addresses which combines all known HOPR safe addresses, EOA addresses and the channels contract address. \nOnce an ERC20 transfer event is being handled, it will check against this set of addresses. \nIf the address is known, the balance will be fetched from chain via the RPC (sync operation) and the result stored in the in-memory data structure. If a balance is fetched via the GraphQL API it will try to read the balance from the data structure. If the key is not present, an error will be returned. If the key (address) is present and no balance is known yet, it will be fetched directly from the RPC (sync operation), stored in the data structure and returned to the API caller. If the balance is known, it will be returned directly.\nA similar approach is taken for native transfers. For these the indexer\nsubscribes to new blocks and checks all transactions in a new block for known\naddresses. If a known address is found, the native balance is fetched from chain\nvia the RPC (sync operation) and the result stored in the in-memory data\nstructure. The GraphQL API behaves the same way as for ERC20 balances.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-06T14:32:00.707979111+01:00","updated_at":"2025-11-06T15:05:04.217358458+01:00","source_repo":"."}
{"id":"blokli-7vy","content_hash":"d3a921d847ed4e07a2191e40630358c7e4bb9339a161bffb6734d08af74db1ba","title":"Phase 1.6: Event Recording and Retrieval","description":"Implement subscription stream handling, event recording with timestamps/sequence numbers, GET /events endpoint","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.146013411+01:00","updated_at":"2025-12-02T09:26:04.146013411+01:00","source_repo":"."}
{"id":"blokli-82w","content_hash":"25d90d40bfedc0f11d212762728025a9631c4fba84d3debdb90950b3ed0f631a","title":"Phase 1.5: Action Trigger Endpoints","description":"Implement POST /trigger/channel-open, /trigger/channel-close, /trigger/announce blockchain action endpoints","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.139405491+01:00","updated_at":"2025-12-02T09:26:04.139405491+01:00","source_repo":"."}
{"id":"blokli-8em","content_hash":"ad888b0ddda942bab22ad15365b35992469edf1b61d77622016a0762aeea6a6d","title":"Update network.rs for network-specific tuning","description":"Remove/deprecate tx_polling_interval(), add block_time_window_size() method for per-network configuration","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.420931964+01:00","updated_at":"2025-12-01T20:04:23.420931964+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-8em","depends_on_id":"blokli-jkz","type":"blocks","created_at":"2025-12-01T20:04:26.052813101+01:00","created_by":"daemon"}]}
{"id":"blokli-8k0","content_hash":"a5a25822143a9c46db7ddd85c796180648351d9a68bcee61100adf174b83f16c","title":"add missing prometheus feature and expose metrics","description":"There are already lots of metrics prepared. Add the missing prometheus feature and make sure its usable.","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-07T15:45:44.653031737+01:00","updated_at":"2025-11-07T15:45:44.653031737+01:00","source_repo":"."}
{"id":"blokli-bli","content_hash":"39d237a5d4d5001e9f425b15efb813d75272edcb881bda1b5026041afe2f7317","title":"Phase 2.1: Project Setup and Scenario Models","description":"Create coordinator Rust package, define YAML data models, implement deserialization and validation","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.691191168+01:00","updated_at":"2025-12-02T09:26:16.691191168+01:00","source_repo":"."}
{"id":"blokli-bnn","content_hash":"86ed676358c40cabd6196185714dd7ecbdebeb42109242638ac5b2ffbb109049","title":"Phase 4.2: Justfile Integration","description":"Add e2e-test, e2e-scenario, e2e-up, e2e-down, e2e-reports commands to justfile","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:41.528389862+01:00","updated_at":"2025-12-02T09:26:41.528389862+01:00","source_repo":"."}
{"id":"blokli-cbp","content_hash":"c9c555e397ab4420d780c22cce57b36095e23ac32e4f839cb9a47fc53434c7b0","title":"Phase 3.4: Integration Testing and Documentation","description":"Test full stack startup, verify connectivity, test scaling (10/50/100 bots), create E2E README","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:29.059969268+01:00","updated_at":"2025-12-02T09:26:29.059969268+01:00","source_repo":"."}
{"id":"blokli-ccu","content_hash":"75851c8c24e499d55cdccbfe91d55c6c8eb7acfc6629777d6ba09ad9705267a1","title":"Phase 1.4: Subscription Management Endpoints","description":"Implement POST /subscribe/channels, /subscribe/accounts, /subscribe/graph, DELETE /subscribe endpoints","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.132719174+01:00","updated_at":"2025-12-02T09:26:04.132719174+01:00","source_repo":"."}
{"id":"blokli-crp","content_hash":"917272c3521ca148cec6acac8cca3e3f46ad4a7f2441e1197bef435d139b77dc","title":"Phase 1.1: Project Setup and Cargo Configuration","description":"Create bot-runner Rust workspace package with Axum, tokio, serde, uuid, chrono, blokli-client dependencies","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:00.884903596+01:00","updated_at":"2025-12-02T09:26:00.884903596+01:00","source_repo":"."}
{"id":"blokli-ct0","content_hash":"2049de8068e12a3ee4412b8e90782ae53b270d1296249d23a7fa39fcc1d8cec5","title":"Consider event publication performance optimization","description":"Investigate performance of event publication: 1) Profile event construction overhead, 2) Consider caching frequently accessed data, 3) Evaluate if full GraphQL object is always needed, 4) Add metrics for event publication latency. Questions to answer: How many subscribers are typical? Average event publication latency? Scenarios with very high event rates? Should we batch events? Estimated: 2-4 hours.","status":"open","priority":4,"issue_type":"task","created_at":"2025-11-06T12:38:21.169182267+01:00","updated_at":"2025-11-06T12:38:21.169182267+01:00","source_repo":"."}
{"id":"blokli-dfx","content_hash":"44b6ef633af9bc693da23a7119e0485aa2d4dca5b34a7f62124d8f79f96b055a","title":"Fix compilation warnings in handlers.rs","description":"Remove unused import chain_events::ChainEventType (line 1324), prefix unused variables with underscore (_diff at lines 2004/2110, _decoded at lines 3210/3214), and remove/document unused constant PRICE_PER_PACKET (line 2452). Can run 'cargo fix --lib -p blokli-chain-indexer --tests' for automatic fixes. Estimated: 15 minutes.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-11-06T12:37:47.077741848+01:00","updated_at":"2025-11-06T12:37:47.077741848+01:00","source_repo":"."}
{"id":"blokli-ewg","content_hash":"1911b68ba59240afff4910574b850f7610cbe89bd5c32d59812993c5d64b832b","title":"Full e2e test suite for GraphQL API","description":"Create comprehensive e2e test suite that tests GraphQL API with full integration of indexer and database. Test should: 1) Start Anvil instance, 2) Generate pre-defined set of transactions via GraphQL mutations covering wide range of scenarios, 3) Index logs from transactions and store in database, 4) Perform GraphQL queries and subscriptions to verify data correctness and full integration. This is a major test infrastructure piece.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-11-06T12:41:00.084027248+01:00","updated_at":"2025-11-06T12:41:00.084027248+01:00","source_repo":"."}
{"id":"blokli-hcs","content_hash":"6a6f8e61731ab9b25f0a1cc5beb714aae9ce3bd2339167fba2c030852eaa4034","title":"Phase 1.3: REST API Discovery and Health Endpoints","description":"Implement GET /bots, GET /health, GET /bots/{bot_id}/health, GET /bots/{bot_id}/info using Axum","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.125955051+01:00","updated_at":"2025-12-02T09:26:04.125955051+01:00","source_repo":"."}
{"id":"blokli-hsp","content_hash":"f9987cfa06d112c90a3a56c5a32ce087fb3f378a6a3778781e24e403521f5a97","title":"GraphQL subscriptions integration test with 2-phase protocol","description":"Create integration test that specifically covers GraphQL subscriptions and ensures the 2-phase protocol works correctly. This test should verify subscription lifecycle, event delivery, and protocol compliance. Related to full e2e test suite but focused specifically on subscription mechanics.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-11-06T12:41:09.165586379+01:00","updated_at":"2025-11-06T12:41:09.165586379+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-hsp","depends_on_id":"blokli-ewg","type":"related","created_at":"2025-11-06T12:41:26.359933258+01:00","created_by":"daemon"}]}
{"id":"blokli-jk0","content_hash":"7c86afb290e436065ab6da8679e2fc5ae906a7a97289066ac7b4f7cea7b06cda","title":"Phase 4.3: Validation and Debugging","description":"Run all scenarios, verify reports, test with different bot counts (10/25/50), performance profiling","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:41.535229637+01:00","updated_at":"2025-12-02T09:26:41.535229637+01:00","source_repo":"."}
{"id":"blokli-jkz","content_hash":"1edfcd33c8fba6650f99694a3fd9d05b5abcddc8fc73a788b0eef43d37507b4b","title":"Add configuration options","description":"Update bloklid/config.rs with new RPC config fields and update example-config.toml with defaults and documentation","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.41394715+01:00","updated_at":"2025-12-01T20:04:23.41394715+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-jkz","depends_on_id":"blokli-0w4","type":"blocks","created_at":"2025-12-01T20:04:26.04525789+01:00","created_by":"daemon"}]}
{"id":"blokli-k1g","content_hash":"3a22ca873ba34464bf3923b0e80f461ed4f7125be9c1314750b7a248a7748f08","title":"E2E Bot Load Testing System","description":"Build comprehensive end-to-end load testing system for Blokli GraphQL API with 10-500 concurrent bots, subscription validation, and automated orchestration","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:25:45.178643081+01:00","updated_at":"2025-12-02T09:25:45.178643081+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-k1g","depends_on_id":"blokli-2s8","type":"blocks","created_at":"2025-12-02T09:25:53.875890223+01:00","created_by":"daemon"},{"issue_id":"blokli-k1g","depends_on_id":"blokli-u2z","type":"blocks","created_at":"2025-12-02T09:26:12.088682975+01:00","created_by":"daemon"},{"issue_id":"blokli-k1g","depends_on_id":"blokli-5bj","type":"blocks","created_at":"2025-12-02T09:26:25.367888698+01:00","created_by":"daemon"},{"issue_id":"blokli-k1g","depends_on_id":"blokli-1w5","type":"blocks","created_at":"2025-12-02T09:26:38.22695494+01:00","created_by":"daemon"}]}
{"id":"blokli-l72","content_hash":"6266906db0944433f9cb2c5c81f5124127ffc32383b363153b0c6641aede4f70","title":"Docker compose setup for local testing","description":"Create Docker compose setup for local testing that: 1) Starts Postgres DB, 2) Starts blokli instances configured to use the DB and index Rotsee network, 3) Uses locally built blokli image, 4) Includes local Docker registry for pushing and using blokli image. This enables easy local testing and development with full infrastructure.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-06T12:41:15.70624662+01:00","updated_at":"2025-11-06T12:41:15.70624662+01:00","source_repo":"."}
{"id":"blokli-lbw","content_hash":"37071111fa30a8be4ada71caa93da2ff39a4fa406ca5141d9f89b97ecbc4f68b","title":"Run full test suite verification","description":"Run full test suite to verify all tests pass: 'just test', 'cargo test --package blokli-chain-indexer'. Verify: all unit tests, state tests, handlers tests (now unblocked), block tests, config tests, snapshot tests. No test timeouts or hangs. CI/CD pipeline passes. Estimated: 30 minutes. NOTE: Was blocked by hanging handler tests, now unblocked\\!","status":"open","priority":0,"issue_type":"task","created_at":"2025-11-06T12:37:53.99435551+01:00","updated_at":"2025-11-06T12:37:53.99435551+01:00","source_repo":"."}
{"id":"blokli-mam","content_hash":"d710768960acc83d007e1d40d087d671a43bb14360426f9238a7a088efb2f658","title":"Phase 1.2: Bot Pool and State Management","description":"Implement BotRunnerState, BotState, EventStore with Arc/RwLock, load BOT_COUNT from env, create deterministic bot identities","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:04.119214523+01:00","updated_at":"2025-12-02T09:26:04.119214523+01:00","source_repo":"."}
{"id":"blokli-mqs","content_hash":"d7872ea96e5bfde4cf94634461279c93918f8a1f511698064bbb43568f6b018c","title":"Validate and test with just quick","description":"Run formatting, linting, and compilation checks to ensure code quality","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.435394263+01:00","updated_at":"2025-12-01T20:04:23.435394263+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-mqs","depends_on_id":"blokli-pai","type":"blocks","created_at":"2025-12-01T20:04:26.068031143+01:00","created_by":"daemon"}]}
{"id":"blokli-o5t","content_hash":"f783b8d2cc3370002a87931cd0fe4f2ebb4a1e409856e3d1a34428765ba03ca5","title":"Phase 3.3: Docker Compose File","description":"Define all services (anvil, postgres, bloklid, bot-runner, coordinator) with health checks and dependencies","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:29.052955167+01:00","updated_at":"2025-12-02T09:26:29.052955167+01:00","source_repo":"."}
{"id":"blokli-p5k","content_hash":"1098c2a897182cbb569594e9aef3d0410edd6be8b2db49275cab2b76fcfdb948","title":"Phase 3.1: Contract Deployment Container","description":"Create deploy script with forge, write contract addresses to /shared/contracts.json, create Dockerfile","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:29.038999619+01:00","updated_at":"2025-12-02T09:26:29.038999619+01:00","source_repo":"."}
{"id":"blokli-pai","content_hash":"53bbca38bea1bb2b7873eedff6a9af7329ea15005e59b6211974456e90ef0737","title":"Write integration tests","description":"Test block time tracking with mocked block fetching, verify dynamic polling interval adaptation, test chain reorg reset","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-01T20:04:23.428215045+01:00","updated_at":"2025-12-01T20:04:23.428215045+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-pai","depends_on_id":"blokli-3s7","type":"blocks","created_at":"2025-12-01T20:04:26.060470012+01:00","created_by":"daemon"}]}
{"id":"blokli-qab","content_hash":"d03f756d145f2c537faf6397bb1b4b5987c6871d02060769c4bfc0f8bc534947","title":"Re-enable and refactor integration tests","description":"Integration tests in chain/indexer/tests/indexer_integration_test.rs were disabled due to API changes from removing chain-actions crate. Tests are wrapped in #[cfg(disabled_pending_refactor)]. See INTEGRATION_TEST_REFACTOR.md for detailed plan. Estimated: 10-15 hours across 4 phases.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-06T12:37:40.543695629+01:00","updated_at":"2025-11-06T12:37:40.543695629+01:00","source_repo":"."}
{"id":"blokli-qk6","content_hash":"feceac4b21c5402352a2e9b2f3f9ca480d841f107bb27aa8a21af4a9e08ad874","title":"Phase 4.1: Baseline Test Scenarios","description":"Create 5 YAML scenarios: channel-lifecycle, multi-subscriber, concurrent-operations, account-announcement, graph-subscription","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:41.521613606+01:00","updated_at":"2025-12-02T09:26:41.521613606+01:00","source_repo":"."}
{"id":"blokli-qom","content_hash":"e9f2d5d5e834e8aff4c9fbb2351844ac44a569ceb97816d2c43667d2c8fd43dc","title":"Phase 2.2: Bot Discovery and HTTP Client","description":"Implement bot-runner discovery via environment variable, create BotRunnerClient wrapper, test connectivity","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.698329382+01:00","updated_at":"2025-12-02T09:26:16.698329382+01:00","source_repo":"."}
{"id":"blokli-u2z","content_hash":"69cb4ec7ad3744a9bf6307dff39dd7b079b911aa545ca2ad97abf852ec51ea8c","title":"Phase 2: Coordinator Service","description":"Implement scenario parser, execution engine, event validation, and report generation (32-34 hours / 2-3 days)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:10.000915236+01:00","updated_at":"2025-12-02T09:26:10.000915236+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-u2z","depends_on_id":"blokli-bli","type":"blocks","created_at":"2025-12-02T09:26:19.527915419+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-qom","type":"blocks","created_at":"2025-12-02T09:26:19.535729931+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-49e","type":"blocks","created_at":"2025-12-02T09:26:19.543725013+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-yjy","type":"blocks","created_at":"2025-12-02T09:26:19.551150846+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-4rw","type":"blocks","created_at":"2025-12-02T09:26:19.559202203+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-2l2","type":"blocks","created_at":"2025-12-02T09:26:19.566951523+01:00","created_by":"daemon"},{"issue_id":"blokli-u2z","depends_on_id":"blokli-5bj","type":"blocks","created_at":"2025-12-02T09:26:46.85221985+01:00","created_by":"daemon"}]}
{"id":"blokli-u51","content_hash":"1e65e8515aa157f0614865763dc6602c01c6e95876d3fd19802f1bf7958d7394","title":"Implement simplified Safe module address design","description":"Simplified design to expose Safe module addresses via GraphQL API.\n\nExtends hopr_safe_contract table instead of modifying account system.\nUses additive approach - no changes to existing account logic.\nRegisteredNodeSafe becomes verification-only (no database updates).\n\nKey changes:\n- Add module_address and chain_key to hopr_safe_contract table\n- New GraphQL Safe type with queries and subscription\n- Index NewHoprNodeStakeModuleForSafe events via stake factory handler\n- Query transaction sender via RPC to get chain_key\n\nSee design field for complete implementation details.","design":"# Design: Safe Module Address via hopr_safe_contract Table (Simplified)\n\n## Overview\n\nThis is a **simplified, additive design** that extends the existing `hopr_safe_contract` table to track Safe deployments with their module addresses and owner chain keys. This approach:\n\n- **Extends** the existing `hopr_safe_contract` table (adds `module_address` and `chain_key` columns)\n- **Leaves** the `account` table completely unchanged\n- **Makes** Safes the \"parent\" entity (accounts reference safes, not vice versa)\n- **Adds** new GraphQL queries/subscriptions for Safe information\n- **Keeps** design additive and non-intrusive to existing account logic\n\n## Problem Statement\n\nCurrently, the API exposes Safe addresses (via `account_state.safe_address`) but not the associated HOPR Node Management Module addresses. Clients need the module address to interact with node management functionality.\n\nThe existing `hopr_safe_contract` table exists but is:\n- Not fully utilized (only stores address and deployment provenance)\n- Not connected to the indexer's event processing\n- Not exposed in the GraphQL API\n\n## Solution: Extend hopr_safe_contract Table\n\nInstead of modifying the account system, we extend `hopr_safe_contract` to be the authoritative source for Safe deployment information, and expose it through new GraphQL queries.\n\n---\n\n## Core Principles\n\n### 1. Safes Are Deployed First\n- `NewHoprNodeStakeModuleForSafe` event creates entries in `hopr_safe_contract`\n- Transaction sender becomes the `chain_key` (owner address)\n- Safes exist independently before accounts are created\n\n### 2. RegisteredNodeSafe Is Verification Only\n- Checks data consistency in `hopr_safe_contract` table\n- Verifies `safe_address` matches database\n- Verifies `nodeAddress` matches `chain_key`\n- Logs errors but does NOT create or update records\n- Does NOT emit events\n\n### 3. Accounts Reference Safes\n- Existing `account_state.safe_address` links to `hopr_safe_contract.address`\n- No changes to account table structure\n- No changes to account creation logic\n\n### 4. Additive, Not Intrusive\n- Zero modifications to existing account system\n- Only adds new functionality\n- Backward compatible\n\n---\n\n## 1. Database Schema Changes\n\n### 1.1 Migration\n\n**File**: `db/migration/src/m0XX_add_module_and_chain_key_to_safe_contract.rs`\n\n**Migration Up**:\n```sql\n-- Add new columns\nALTER TABLE hopr_safe_contract\nADD COLUMN module_address BINARY(20) NOT NULL;\n\nALTER TABLE hopr_safe_contract\nADD COLUMN chain_key BINARY(20) NOT NULL;\n\n-- Add indices for lookups\nCREATE INDEX idx_hopr_safe_contract_chain_key\nON hopr_safe_contract(chain_key);\n\nCREATE INDEX idx_hopr_safe_contract_address\nON hopr_safe_contract(address);\n\n-- Add idempotency constraint on event provenance\nCREATE UNIQUE INDEX idx_hopr_safe_contract_event\nON hopr_safe_contract(deployed_block, deployed_tx_index, deployed_log_index);\n```\n\n**Migration Down**:\n```sql\n-- Drop indices\nDROP INDEX IF EXISTS idx_hopr_safe_contract_event;\nDROP INDEX IF EXISTS idx_hopr_safe_contract_address;\nDROP INDEX IF EXISTS idx_hopr_safe_contract_chain_key;\n\n-- Drop columns\nALTER TABLE hopr_safe_contract DROP COLUMN chain_key;\nALTER TABLE hopr_safe_contract DROP COLUMN module_address;\n```\n\n### 1.2 Updated Schema\n\n**hopr_safe_contract**:\n```\nhopr_safe_contract {\n    int id PK\n    binary(20) address UK \"Safe contract address\"\n    binary(20) module_address \"HOPR Node Management Module address\"\n    binary(20) chain_key \"Transaction sender / owner address\"\n    bigint deployed_block \"Block number where deployed\"\n    bigint deployed_tx_index \"Transaction index in block\"\n    bigint deployed_log_index \"Log index in transaction\"\n    UNIQUE(deployed_block, deployed_tx_index, deployed_log_index)\n}\n```\n\n**Key Points**:\n- `module_address` - Module contract address from event\n- `chain_key` - Transaction sender (node's chain key owner)\n- Composite UNIQUE constraint for idempotency\n- Indices on `chain_key` and `address` for efficient lookups\n\n### 1.3 No Changes to Other Tables\n\n- **account** - Unchanged\n- **account_state** - Keep `safe_address` field for simple query joins\n\n### 1.4 Entity Regeneration\n\nAfter migration, regenerate SeaORM entities:\n```bash\nsea-orm-cli generate entity \\\n    -o db/entity/src/codegen \\\n    --with-serde both\n```\n\n---\n\n## 2. RPC Operations Extension\n\n### 2.1 Get Transaction Sender\n\n**File**: `chain/rpc/src/lib.rs`\n\nAdd method to RPC operations trait:\n\n```rust\n#[async_trait]\npub trait HoprIndexerRpcOperations {\n    // ... existing methods ...\n\n    /// Get transaction sender (from address) by transaction hash\n    ///\n    /// Used to determine the chain_key when processing\n    /// NewHoprNodeStakeModuleForSafe events, where the transaction\n    /// sender is the account owner.\n    ///\n    /// # Arguments\n    /// * `tx_hash` - Transaction hash from log\n    ///\n    /// # Returns\n    /// Address of transaction sender (from field)\n    async fn get_transaction_sender(\u0026self, tx_hash: Hash) -\u003e Result\u003cAddress\u003e;\n}\n```\n\n**Implementation**:\n\n```rust\nasync fn get_transaction_sender(\u0026self, tx_hash: Hash) -\u003e Result\u003cAddress\u003e {\n    let tx = self.provider\n        .get_transaction_by_hash(tx_hash)\n        .await?\n        .ok_or_else(|| anyhow!(\"Transaction not found: {}\", tx_hash))?;\n\n    Ok(tx.from.to_hopr_address())\n}\n```\n\n**Performance**: One RPC call per Safe deployment. Since Safe deployments are infrequent (once per node), this is acceptable and caching is not needed.\n\n---\n\n## 3. Database API Changes\n\n### 3.1 New Operations\n\n**File**: `db/core/src/safe_contracts.rs` (NEW or extend existing)\n\n#### Create Safe Contract Entry\n\n```rust\n/// Create safe contract entry from deployment event\n///\n/// # Arguments\n/// * `safe_address` - Safe contract address from event\n/// * `module_address` - Module contract address from event\n/// * `chain_key` - Transaction sender (owner address)\n/// * `block` - Deployment block number\n/// * `tx_index` - Transaction index\n/// * `log_index` - Log index\n///\n/// # Idempotency\n/// Uses ON CONFLICT on (deployed_block, deployed_tx_index, deployed_log_index)\nasync fn create_safe_contract\u003c'a\u003e(\n    \u0026'a self,\n    tx: OptTx\u003c'a\u003e,\n    safe_address: Address,\n    module_address: Address,\n    chain_key: Address,\n    block: u64,\n    tx_index: u64,\n    log_index: u64,\n) -\u003e Result\u003ci64\u003e;\n```\n\n**Implementation Notes**:\n- Insert into `hopr_safe_contract` table\n- Use `ON CONFLICT DO NOTHING` for idempotency\n- Return the generated `id`\n\n**Idempotency**:\n```sql\nINSERT INTO hopr_safe_contract (address, module_address, chain_key, deployed_block, deployed_tx_index, deployed_log_index)\nVALUES (?, ?, ?, ?, ?, ?)\nON CONFLICT (deployed_block, deployed_tx_index, deployed_log_index)\nDO NOTHING\nRETURNING id;\n```\n\n#### Verify Safe Contract\n\n```rust\n/// Verify safe contract exists and chain_key matches expected value\n///\n/// Used by RegisteredNodeSafe handler for verification only\n///\n/// # Arguments\n/// * `safe_address` - Safe contract address from event\n/// * `expected_chain_key` - Expected chain_key (from event.nodeAddress)\n///\n/// # Returns\n/// * `Ok(true)` - Safe exists and chain_key matches\n/// * `Ok(false)` - Safe exists but chain_key does NOT match\n/// * `Err(_)` - Safe does not exist\nasync fn verify_safe_contract\u003c'a\u003e(\n    \u0026'a self,\n    tx: OptTx\u003c'a\u003e,\n    safe_address: Address,\n    expected_chain_key: Address,\n) -\u003e Result\u003cbool\u003e;\n```\n\n**Implementation Notes**:\n- Query `hopr_safe_contract` by `address`\n- Compare `chain_key` with expected value\n- Return true if matches, false if mismatches\n- Return error if safe not found\n\n---\n\n## 4. Indexer Changes\n\n### 4.1 New Handler: Stake Factory\n\n**File**: `chain/indexer/src/handlers/stake_factory.rs` (NEW)\n\n```rust\nuse blokli_chain_rpc::HoprIndexerRpcOperations;\nuse blokli_db::{BlokliDbAllOperations, OpenTransaction};\nuse hopr_bindings::hopr_node_stake_factory::HoprNodeStakeFactory::HoprNodeStakeFactoryEvents;\nuse hopr_primitive_types::prelude::SerializableLog;\nuse tracing::{error, info};\n\nuse super::ContractEventHandlers;\nuse crate::errors::Result;\n\nimpl\u003cT, Db\u003e ContractEventHandlers\u003cT, Db\u003e\nwhere\n    T: HoprIndexerRpcOperations + Clone + Send + 'static,\n    Db: BlokliDbAllOperations + Clone,\n{\n    pub(super) async fn on_stake_factory_event(\n        \u0026self,\n        tx: \u0026OpenTransaction,\n        log: \u0026SerializableLog,\n        event: HoprNodeStakeFactoryEvents,\n        is_synced: bool,\n        block: u64,\n        tx_index: u64,\n        log_index: u64,\n    ) -\u003e Result\u003c()\u003e {\n        match event {\n            HoprNodeStakeFactoryEvents::NewHoprNodeStakeModuleForSafe(deployed) =\u003e {\n                let module_addr = deployed.module.to_hopr_address();\n                let safe_addr = deployed.safe.to_hopr_address();\n\n                // Query RPC for transaction sender (this is the chain_key)\n                let chain_key = self.rpc\n                    .get_transaction_sender(log.transaction_hash)\n                    .await\n                    .map_err(|e| {\n                        error!(\n                            tx_hash = %log.transaction_hash,\n                            error = %e,\n                            \"Failed to get transaction sender for NewHoprNodeStakeModuleForSafe\"\n                        );\n                        e\n                    })?;\n\n                info!(\n                    chain_key = %chain_key,\n                    safe = %safe_addr,\n                    module = %module_addr,\n                    block,\n                    \"Creating safe contract entry from deployment\"\n                );\n\n                // Create safe contract entry\n                let safe_id = self.db\n                    .create_safe_contract(\n                        Some(tx),\n                        safe_addr,\n                        module_addr,\n                        chain_key,\n                        block, tx_index, log_index,\n                    )\n                    .await?;\n\n                info!(\n                    safe_id,\n                    safe = %safe_addr,\n                    \"Safe contract entry created\"\n                );\n\n                // Emit SafeDeployed event if synced\n                if is_synced {\n                    self.indexer_state\n                        .publish_event(crate::state::IndexerEvent::SafeDeployed(safe_addr));\n                }\n            }\n            _ =\u003e {}\n        }\n\n        Ok(())\n    }\n}\n```\n\n**Key Points**:\n- Query transaction sender via RPC to get `chain_key`\n- Insert into `hopr_safe_contract` table\n- Emit `SafeDeployed` event for subscriptions (when synced)\n- Handle idempotency via unique constraint\n\n### 4.2 Updated Handler: Safe Registry (Verification Only)\n\n**File**: `chain/indexer/src/handlers/node_safe_registry.rs`\n\nUpdate the `RegisteredNodeSafe` event handler:\n\n```rust\nHoprNodeSafeRegistryEvents::RegisteredNodeSafe(registered) =\u003e {\n    let safe_addr = registered.safeAddress.to_hopr_address();\n    let node_addr = registered.nodeAddress.to_hopr_address();\n\n    info!(\n        node_address = %node_addr,\n        safe_address = %safe_addr,\n        \"Verifying RegisteredNodeSafe event\"\n    );\n\n    // VERIFICATION ONLY - Check safe exists and chain_key matches\n    match self.db.verify_safe_contract(Some(tx), safe_addr, node_addr).await {\n        Ok(true) =\u003e {\n            // Safe exists and chain_key matches - all good\n            debug!(\n                node_address = %node_addr,\n                safe_address = %safe_addr,\n                \"RegisteredNodeSafe verified successfully\"\n            );\n        }\n        Ok(false) =\u003e {\n            // Safe exists but chain_key MISMATCH\n            error!(\n                node_address = %node_addr,\n                safe_address = %safe_addr,\n                \"RegisteredNodeSafe chain_key MISMATCH! \\\n                 Event nodeAddress does not match database chain_key. \\\n                 This indicates a protocol violation or data inconsistency.\"\n            );\n        }\n        Err(e) =\u003e {\n            // Safe doesn't exist or query failed\n            error!(\n                node_address = %node_addr,\n                safe_address = %safe_addr,\n                error = %e,\n                \"RegisteredNodeSafe verification failed. \\\n                 Safe may not exist in database. \\\n                 Expected NewHoprNodeStakeModuleForSafe to create safe first. \\\n                 This indicates events are out of order.\"\n            );\n        }\n    }\n\n    // Do NOT emit any events - no data was changed\n}\n```\n\n**Important Changes**:\n- Handler performs **verification only** and does NOT update database\n- Checks that safe exists in `hopr_safe_contract` table\n- Verifies `chain_key` matches `nodeAddress` from event\n- Logs errors but continues indexing\n- Does NOT emit events (no state changes)\n\n### 4.3 Account Handlers\n\n**NO CHANGES** - Existing `RegisteredNodeSafe` and `KeyBinding` handlers for account creation continue to work unchanged.\n\n### 4.4 Configuration Changes\n\n**File**: `chain/indexer/src/config.rs`\n\nAdd stake factory contract address:\n\n```rust\npub struct ContractAddresses {\n    pub announcements: Address,\n    pub channels: Address,\n    pub node_safe_registry: Address,\n    pub stake_factory: Address,  // NEW\n    // ... other contracts\n}\n```\n\n**File**: `chain/indexer/src/handlers/mod.rs`\n\nAdd event routing:\n\n```rust\nmatch log.address {\n    addr if addr == contracts.stake_factory =\u003e {\n        let event = decode_event::\u003cHoprNodeStakeFactoryEvents\u003e(\u0026log)?;\n        self.on_stake_factory_event(tx, \u0026log, event, is_synced, block, tx_index, log_index).await?;\n    }\n    // ... other contracts\n}\n```\n\n---\n\n## 5. GraphQL API Changes\n\n### 5.1 New Type: Safe\n\n**File**: `design/target-api-schema.graphql`\n\n```graphql\n\"\"\"\nHOPR Safe contract deployment information\n\"\"\"\ntype Safe {\n  \"\"\"Safe contract address (hexadecimal format)\"\"\"\n  address: String!\n\n  \"\"\"HOPR Node Management Module address (hexadecimal format)\"\"\"\n  moduleAddress: String!\n\n  \"\"\"Chain key (owner address, hexadecimal format)\"\"\"\n  chainKey: String!\n}\n```\n\n**Notes**:\n- Field naming matches `Account` type conventions (`chainKey` not `account`)\n- No `deployedBlock` field (keeping it simple)\n- All addresses in hexadecimal string format\n\n### 5.2 New Result Types\n\n```graphql\n\"\"\"Result type for single safe queries\"\"\"\nunion SafeResult = Safe | InvalidAddressError | QueryFailedError\n\n\"\"\"Success response for safes list query\"\"\"\ntype SafesList {\n  \"\"\"List of safes\"\"\"\n  safes: [Safe!]!\n}\n\n\"\"\"Result type for safes list query\"\"\"\nunion SafesResult = SafesList | QueryFailedError\n```\n\n**Pattern**: Follows existing conventions (`AccountsResult`, `HoprBalanceResult`)\n\n### 5.3 New Queries\n\n```graphql\nextend type QueryRoot {\n  \"\"\"\n  Retrieve safe by contract address\n\n  Returns Error with code INVALID_ADDRESS if address format is invalid.\n  Returns Error with code QUERY_FAILED if query fails.\n  Returns None if safe is not found.\n  \"\"\"\n  safe(\n    \"\"\"Safe contract address to query (hexadecimal format)\"\"\"\n    address: String!\n  ): SafeResult\n\n  \"\"\"\n  Retrieve safe by chain key (owner address)\n\n  Returns Error with code INVALID_ADDRESS if address format is invalid.\n  Returns Error with code QUERY_FAILED if query fails.\n  Returns None if safe is not found.\n  \"\"\"\n  safeByChainKey(\n    \"\"\"Chain key to query (hexadecimal format)\"\"\"\n    chainKey: String!\n  ): SafeResult\n\n  \"\"\"\n  Retrieve all safes\n\n  Returns all safe contracts indexed by the system.\n  Returns Error with code QUERY_FAILED if query fails.\n  \"\"\"\n  safes: SafesResult!\n}\n```\n\n**Notes**:\n- No pagination (keeping it simple per requirements)\n- Returns `None` (GraphQL nullable) for not found\n- Matches existing query patterns\n\n### 5.4 New Subscription\n\n```graphql\nextend type SubscriptionRoot {\n  \"\"\"\n  Subscribe to newly deployed safes\n\n  Emits Safe deployment events in real-time as they are indexed.\n  \"\"\"\n  safeDeployed: Safe!\n}\n```\n\n### 5.5 Optional: Account Type Extension\n\n**File**: `design/target-api-schema.graphql`\n\n```graphql\ntype Account {\n  # ... existing fields ...\n\n  \"\"\"\n  Safe contract information (if account is linked to a safe)\n\n  Resolved by joining account_state.safe_address with hopr_safe_contract.address.\n  Returns null if account has no linked safe.\n  \"\"\"\n  safe: Safe\n}\n```\n\n**Implementation**: GraphQL resolver joins `account_state.safe_address` with `hopr_safe_contract.address`\n\n### 5.6 Implementation\n\n**File**: `api/src/types.rs` or similar\n\n```rust\nuse hopr_primitive_types::prelude::Address;\n\npub struct Safe {\n    pub address: Address,\n    pub module_address: Address,\n    pub chain_key: Address,\n}\n\n#[Object]\nimpl Safe {\n    async fn address(\u0026self) -\u003e String {\n        self.address.to_hex()\n    }\n\n    async fn module_address(\u0026self) -\u003e String {\n        self.module_address.to_hex()\n    }\n\n    async fn chain_key(\u0026self) -\u003e String {\n        self.chain_key.to_hex()\n    }\n}\n```\n\n**File**: `api/src/resolvers/safe.rs` (NEW)\n\nImplement query resolvers:\n- `safe(address: String!)` - Query by safe address\n- `safeByChainKey(chainKey: String!)` - Query by chain key\n- `safes()` - List all safes\n\nImplement subscription resolver:\n- `safeDeployed` - Stream new safe deployments\n\n**File**: `api/src/resolvers/account.rs` (OPTIONAL)\n\nAdd field resolver:\n```rust\nimpl Account {\n    async fn safe(\u0026self, ctx: \u0026Context\u003c'_\u003e) -\u003e Result\u003cOption\u003cSafe\u003e\u003e {\n        // Join account_state.safe_address with hopr_safe_contract.address\n        // Return None if no safe linked\n    }\n}\n```\n\n---\n\n## 6. Event Flow\n\n### 6.1 Valid Event Order (Happy Path)\n\n```\n1. NewHoprNodeStakeModuleForSafe (Creates Safe Entry)\n   ↓\n   Query RPC: tx.sender → chain_key\n   ↓\n   INSERT INTO hopr_safe_contract (address, module_address, chain_key, ...)\n   ↓\n   Emit SafeDeployed subscription\n   ↓\n   Result: Safe exists in database, ready to be referenced\n\n2. RegisteredNodeSafe (Verifies Data)\n   ↓\n   SELECT * FROM hopr_safe_contract WHERE address = safeAddress\n   ↓\n   VERIFY: chain_key == nodeAddress\n   ↓\n   Log success or error\n   ↓\n   Result: NO database changes, NO event emission\n\n3. KeyBinding / Account Creation (Existing Flow, Unchanged)\n   ↓\n   CREATE/UPDATE account (as before)\n   ↓\n   account_state.safe_address → hopr_safe_contract.address (link established)\n```\n\n### 6.2 Error Cases\n\n**Case 1: RegisteredNodeSafe Before NewHoprNodeStakeModuleForSafe**\n- Error: Safe not found in database\n- Logged: \"RegisteredNodeSafe verification failed. Safe may not exist in database.\"\n- Action: Continue indexing, no updates made\n- **Should never happen in production**\n\n**Case 2: Chain Key Mismatch in RegisteredNodeSafe**\n- Error: `chain_key` in database doesn't match `nodeAddress` in event\n- Logged: \"RegisteredNodeSafe chain_key MISMATCH! Event nodeAddress does not match database chain_key.\"\n- Action: Continue indexing, no updates made\n- **Indicates protocol violation or data inconsistency**\n\n### 6.3 Idempotency\n\n**Duplicate NewHoprNodeStakeModuleForSafe**:\n- Unique constraint on `(deployed_block, deployed_tx_index, deployed_log_index)`\n- Action: `ON CONFLICT DO NOTHING`\n- Result: No duplicate rows, safe to retry\n\n**Duplicate RegisteredNodeSafe**:\n- No database writes (read-only verification)\n- Result: Safe to retry, verification runs again\n\n---\n\n## 7. Implementation Checklist\n\n### Phase 1: Database\n- [ ] Create migration `m0XX_add_module_and_chain_key_to_safe_contract.rs`\n- [ ] Add `module_address` column (BINARY(20) NOT NULL)\n- [ ] Add `chain_key` column (BINARY(20) NOT NULL)\n- [ ] Add unique constraint on event provenance\n- [ ] Add indices for `chain_key` and `address`\n- [ ] Implement down migration\n- [ ] Regenerate SeaORM entities\n- [ ] Verify migration round-trip (up then down)\n\n### Phase 2: RPC\n- [ ] Add `get_transaction_sender()` to `HoprIndexerRpcOperations` trait\n- [ ] Implement method in RPC provider\n- [ ] Add unit tests for transaction sender query\n- [ ] Add error handling for non-existent transactions\n\n### Phase 3: Database API\n- [ ] Implement `create_safe_contract()` method\n- [ ] Add ON CONFLICT handling for idempotency\n- [ ] Implement `verify_safe_contract()` method\n- [ ] Add unit tests for safe creation\n- [ ] Add unit tests for safe verification\n- [ ] Add idempotency tests\n\n### Phase 4: Indexer - Stake Factory\n- [ ] Create `handlers/stake_factory.rs`\n- [ ] Implement `on_stake_factory_event()` handler\n- [ ] Add RPC query for transaction sender\n- [ ] Call safe contract creation API\n- [ ] Add event emission for `SafeDeployed`\n- [ ] Add to indexer configuration\n- [ ] Add event routing in `handlers/mod.rs`\n- [ ] Add unit tests with mocked RPC\n\n### Phase 5: Indexer - Safe Registry\n- [ ] Update `RegisteredNodeSafe` handler to verification-only\n- [ ] Add safe contract verification call\n- [ ] Add error logging for not found\n- [ ] Add error logging for chain_key mismatch\n- [ ] Remove any create/update logic\n- [ ] Remove event emission\n- [ ] Update unit tests\n\n### Phase 6: GraphQL API\n- [ ] Create `Safe` type in `api/src/types.rs`\n- [ ] Create `SafeResult`, `SafesList`, `SafesResult` types\n- [ ] Implement `safe(address)` query resolver\n- [ ] Implement `safeByChainKey(chainKey)` query resolver\n- [ ] Implement `safes()` query resolver\n- [ ] Implement `safeDeployed` subscription resolver\n- [ ] Optional: Implement `Account.safe` field resolver\n- [ ] Update `design/target-api-schema.graphql`\n- [ ] Run `just export-schema-sqlite` to verify\n\n### Phase 7: Testing\n- [ ] Unit test: Create safe with idempotency\n- [ ] Unit test: Verify safe (match case)\n- [ ] Unit test: Verify safe (mismatch case)\n- [ ] Unit test: Verify safe (not found case)\n- [ ] Integration test: Safe deployment flow\n- [ ] Integration test: RegisteredNodeSafe verification\n- [ ] GraphQL test: `safe(address)` query\n- [ ] GraphQL test: `safeByChainKey(chainKey)` query\n- [ ] GraphQL test: `safes()` query\n- [ ] GraphQL test: `safeDeployed` subscription\n- [ ] GraphQL test: `Account.safe` field (optional)\n\n### Phase 8: Documentation\n- [ ] Update `design/target-db-schema.mmd` with new columns\n- [ ] Update `design/architecture.md` with safe deployment flow\n- [ ] Document verification-only behavior of RegisteredNodeSafe\n- [ ] Document GraphQL API additions\n\n---\n\n## 8. Benefits of This Approach\n\n✅ **Non-intrusive** - Zero changes to existing account table or logic\n✅ **Additive** - Only adds new functionality, doesn't modify existing behavior\n✅ **Clean separation** - Safe deployment is independent of account creation\n✅ **Verification** - RegisteredNodeSafe validates data consistency without side effects\n✅ **Flexible** - Safes can exist before accounts (proper temporal ordering)\n✅ **Simple** - No pagination, straightforward queries matching existing patterns\n✅ **Consistent** - Follows existing GraphQL API conventions\n✅ **Idempotent** - Safe to retry event processing\n✅ **Backward compatible** - Existing API continues to work unchanged\n\n---\n\n## 9. Testing Requirements\n\n### 9.1 Unit Tests\n\n**Database API**:\n- Create safe contract entry\n- Create safe with duplicate event (idempotency)\n- Verify safe contract (matching chain_key)\n- Verify safe contract (mismatched chain_key)\n- Verify safe contract (not found)\n\n**RPC**:\n- Get transaction sender\n- Handle non-existent transaction\n- Handle RPC failures\n\n### 9.2 Integration Tests\n\n**Event Processing**:\n- Process `NewHoprNodeStakeModuleForSafe` event\n- Process duplicate `NewHoprNodeStakeModuleForSafe` (idempotency)\n- Process `RegisteredNodeSafe` with matching data\n- Process `RegisteredNodeSafe` with mismatched chain_key\n- Process `RegisteredNodeSafe` before safe exists (error case)\n\n**GraphQL API**:\n- Query safe by address (found)\n- Query safe by address (not found)\n- Query safe by chain key (found)\n- Query safe by chain key (not found)\n- Query all safes (empty list)\n- Query all safes (multiple results)\n- Subscribe to safe deployed events\n- Optional: Query account with safe field\n\n### 9.3 End-to-End Tests\n\n**Happy Path**:\n1. Index `NewHoprNodeStakeModuleForSafe` event\n2. Verify safe appears in database\n3. Query safe via GraphQL (both by address and chain key)\n4. Index `RegisteredNodeSafe` event\n5. Verify no errors logged\n6. Create account (existing flow)\n7. Query account with `safe` field (optional)\n\n**Error Path**:\n1. Index `RegisteredNodeSafe` before safe exists\n2. Verify error is logged\n3. Verify indexing continues\n4. Index `NewHoprNodeStakeModuleForSafe`\n5. Index `RegisteredNodeSafe` again\n6. Verify success this time\n\n---\n\n## 10. Performance Considerations\n\n### 10.1 RPC Query Impact\n\n**Added Latency**: One RPC call per `NewHoprNodeStakeModuleForSafe` event\n\n**Mitigation**:\n- Safe deployments are infrequent (once per node)\n- RPC call only during indexing, not real-time API queries\n- No caching needed due to infrequency\n\n**Estimated Impact**: Negligible\n\n### 10.2 Database Performance\n\n**Indices**:\n- `idx_hopr_safe_contract_chain_key` - Fast lookups by owner\n- `idx_hopr_safe_contract_address` - Fast lookups by safe address\n- Unique index on event provenance - Idempotency with minimal overhead\n\n**Query Performance**:\n- All queries use indexed columns\n- No full table scans expected\n- JOIN performance for `Account.safe` field is acceptable (indexed foreign key via safe_address)\n\n### 10.3 GraphQL Response Size\n\n**Impact**: Minimal - three address fields per safe (60 bytes each)\n\n---\n\n## 11. Security Considerations\n\n### 11.1 Transaction Sender Verification\n\n**Risk**: Transaction sender determines ownership\n\n**Mitigation**:\n- Transaction sender is cryptographically verified by Ethereum\n- Only successfully mined transactions can be indexed\n- RPC queries trusted blockchain data\n- `RegisteredNodeSafe` provides additional verification\n\n### 11.2 Verification Logging\n\n**Purpose**: RegisteredNodeSafe verification catches:\n- Protocol bugs\n- Malicious registry updates\n- Data inconsistencies\n- Chain key mismatches\n\n**Action**: Logged errors allow investigation without blocking indexing\n\n---\n\n## 12. Future Enhancements\n\n### 12.1 Add Deployment Block Information\n\nIf needed in the future, add `deployedBlock` field to GraphQL `Safe` type:\n\n```graphql\ntype Safe {\n  address: String!\n  moduleAddress: String!\n  chainKey: String!\n  deployedBlock: Int!  # Add if needed\n}\n```\n\nData already exists in database, just not exposed.\n\n### 12.2 Add Safe Pagination\n\nIf safe count grows large, add pagination:\n\n```graphql\nsafes(first: Int, after: String): SafeConnection!\n```\n\n### 12.3 Add Safe Filters\n\nAdd filtering to `safes()` query:\n\n```graphql\nsafes(chainKey: String, deployedAfterBlock: Int): SafesResult!\n```\n\n### 12.4 Safe Balance Queries\n\nSince we have safe addresses, could add dedicated safe balance queries:\n\n```graphql\ntype Safe {\n  address: String!\n  moduleAddress: String!\n  chainKey: String!\n  hoprBalance: TokenValueString!  # Future enhancement\n  nativeBalance: TokenValueString!  # Future enhancement\n}\n```\n\n---\n\n## 13. Rollback Plan\n\nIf issues are discovered after deployment:\n\n1. **Stop indexer** to prevent further data changes\n2. **Backup database** before any rollback operations\n3. **Run down migration** to remove new columns\n4. **Revert code changes** to previous version\n5. **Restart indexer** with original code\n6. **Investigate issue** in separate environment\n7. **Fix and re-deploy** when ready\n\n**Data Loss**: Down migration removes `module_address` and `chain_key` columns. Ensure backups exist before running in production.\n\n---\n\n## Appendix A: Error Messages\n\n### Safe Creation Errors\n\n```\nFailed to get transaction sender for NewHoprNodeStakeModuleForSafe\n→ RPC query failed, indexing cannot proceed for this event\n```\n\n```\nFailed to create safe contract entry\n→ Database operation failed, check constraints and data validity\n```\n\n### Verification Errors\n\n```\nRegisteredNodeSafe verification failed. Safe may not exist in database.\n→ Expected NewHoprNodeStakeModuleForSafe to create safe first\n→ Events may be out of order\n```\n\n```\nRegisteredNodeSafe chain_key MISMATCH! Event nodeAddress does not match database chain_key.\n→ Protocol violation or data inconsistency detected\n```\n\n### Idempotency Messages\n\n```\nDuplicate NewHoprNodeStakeModuleForSafe event detected (ON CONFLICT)\n→ Event already processed, skipping (idempotent)\n```\n\n---\n\n## Appendix B: References\n\n### Contract Events\n\n- **NewHoprNodeStakeModuleForSafe**: `hopr_bindings::hopr_node_stake_factory::HoprNodeStakeFactoryEvents`\n- **RegisteredNodeSafe**: `hopr_bindings::hopr_node_safe_registry::HoprNodeSafeRegistryEvents`\n\n### Database Tables\n\n- `hopr_safe_contract` - Safe deployment information with module and owner\n- `account` - Account identity (unchanged)\n- `account_state` - Account state with `safe_address` link (unchanged)\n\n### Related Files\n\n- **Schema**: `design/target-db-schema.mmd`\n- **GraphQL API**: `design/target-api-schema.graphql`\n- **Architecture**: `design/architecture.md`\n\n### Configuration\n\n- Stake factory contract address: From protocol config\n- RPC endpoint: Configured via `IndexerConfig`","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-05T08:33:33.946946066+01:00","updated_at":"2025-12-05T08:39:30.985025517+01:00","source_repo":"."}
{"id":"blokli-ufv","content_hash":"7c41a33c67e0158454a116feec86849f6690824f214dda0a2f0a17d6a3f8a270","title":"Dynamic Block Time Polling with Moving Average","description":"Replace statically configured expected_block_time with dynamic system tracking actual block times using configurable moving average (default: last 10 blocks, starting value: 1 second). Components: BlockTimeTracker module, RpcOperationsConfig updates, indexer polling logic, config changes, unit \u0026 integration tests.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-01T20:04:13.560045741+01:00","updated_at":"2025-12-01T20:04:13.560045741+01:00","source_repo":".","dependencies":[{"issue_id":"blokli-ufv","depends_on_id":"blokli-3ca","type":"blocks","created_at":"2025-12-01T20:04:28.259306195+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-0w4","type":"blocks","created_at":"2025-12-01T20:04:28.267196713+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-3s7","type":"blocks","created_at":"2025-12-01T20:04:28.275082743+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-jkz","type":"blocks","created_at":"2025-12-01T20:04:28.282702534+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-8em","type":"blocks","created_at":"2025-12-01T20:04:28.290218782+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-pai","type":"blocks","created_at":"2025-12-01T20:04:28.297923292+01:00","created_by":"daemon"},{"issue_id":"blokli-ufv","depends_on_id":"blokli-mqs","type":"blocks","created_at":"2025-12-01T20:04:28.30558376+01:00","created_by":"daemon"}]}
{"id":"blokli-yjy","content_hash":"712b2d6310017a8aba33562c24d5674d07a13b6634bfe87db9b11f7e8e4da104","title":"Phase 2.4: Event Validation Logic","description":"Retrieve events from bots, validate event counts/payloads, check ordering/timing, generate failure messages","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T09:26:16.712137082+01:00","updated_at":"2025-12-02T09:26:16.712137082+01:00","source_repo":"."}
